# AUTOGENERATED! DO NOT EDIT! File to edit: ../../../nbs/33_engines.fastai.predict.ipynb.

# %% auto 0
__all__ = ['predict_segmentation', 'predict_segmentation_fastai']

# %% ../../../nbs/33_engines.fastai.predict.ipynb 2
from ...imports import *
from ...processing.all import *
from ...metrics import *
from .losses import *

from fastcore.foundation import *
from fastcore.script import *

from fastai.vision.all import *
from fastai.learner import load_learner, Learner
from shutil import rmtree
from fastai.data.load import DataLoader
from fastcore.transform import Pipeline

from rasterio.windows import Window

import warnings
warnings.filterwarnings("ignore", category=FutureWarning)


# %% ../../../nbs/33_engines.fastai.predict.ipynb 4
@patch
def remove(self:Pipeline, t):
    "Remove an instance of `t` from `self` if present"
    for i,o in enumerate(self.fs):
        if isinstance(o, t.__class__): self.fs.pop(i)
@patch
def set_base_transforms(self:DataLoader):
    "Removes all transforms with a `size` parameter"
    attrs = ['after_item', 'after_batch']
    for i, attr in enumerate(attrs):
        tfms = getattr(self, attr)
        for j, o in enumerate(tfms):
            if hasattr(o, 'size'):
                tfms.remove(o)
        setattr(self, attr, tfms)

# %% ../../../nbs/33_engines.fastai.predict.ipynb 5
def predict_segmentation(path_to_model:str,
                         path_to_image:str,
                         outfile:str,
                         processing_dir:str='temp',
                         tile_size:int=400,
                         tile_overlap:int=100,
                         use_tta:bool=False
    ):
    """Segment image into land cover classes with a pretrained models
    TODO save also information about label and class
    TODO add test-time augmentations"""
    if os.path.exists(processing_dir): 
        print('Processing folder exists')
        return
    os.makedirs(processing_dir)
    print(f'Reading and tiling {path_to_image} to {tile_size}x{tile_size} tiles with overlap of {tile_overlap}px')
    tiler = Tiler(outpath=processing_dir, gridsize_x=int(tile_size), gridsize_y=int(tile_size), 
                  overlap=(int(tile_overlap), int(tile_overlap)))
    tiler.tile_raster(path_to_image, allow_partial_data=True)
    
    # Check whether is possible to use gpu
    cpu = True if not torch.cuda.is_available() else False

    # Loading pretrained model
    
    # PyTorch state dict TODO
    if path_to_model.endswith('.pth') or path_to_model.endswith('.pt'):
        print('Using PyTorch state dict not yet supported')
        print('Removing intermediate files')
        rmtree(processing_dir)
        return
    # fastai learn.export()
    elif path_to_model.endswith('.pkl'):
        learn = load_learner(path_to_model, cpu=cpu)
        test_files = get_image_files(f'{processing_dir}/raster_tiles')
        print('Starting prediction')
        os.makedirs(f'{processing_dir}/predicted_rasters')
        # Works with chunks of 300 patches
        for chunk in range(0, len(test_files), 300):
            test_dl = learn.dls.test_dl(test_files[chunk:chunk+300], num_workers=0, bs=1)
            test_dl.set_base_transforms()
            if use_tta:
                print('not yet supported')
                #batch_tfms = [Dihedral()]
                #item_tfms = [ToTensor(), IntToFloatTensor()]
                #preds = learn.tta(dl=test_dl, batch_tfms=batch_tfms)[0]
            else:
                preds = learn.get_preds(dl=test_dl, with_input=False, with_decoded=False)[0]

            print('Rasterizing predictions')
            for f, p in tqdm(zip(test_files[chunk:chunk+300], preds)):
                #if len(p.shape) == 3: p = p[0]

                with rio.open(f) as src:
                    prof = src.profile.copy()
                prof.update(count=p.shape[0],
                            compress='lzw',
                            dtype='uint8')
                
                with rio.open(f'{processing_dir}/predicted_rasters/{f.stem}.{f.suffix}','w',**prof) as dest:
                    np_pred = p.numpy()#.argmax(axis=0)
                    np_pred = np_pred.round(2)
                    np_pred *= 100
                    np_pred = np_pred.astype(np.int16)
                    dest.write(np_pred[:, tile_overlap//4:(tile_size-tile_overlap//4), 
                                       tile_overlap//4:(tile_size-tile_overlap//4)],
                               window=Window.from_slices((tile_overlap//4,tile_size-tile_overlap//4),
                                                         (tile_overlap//4,tile_size-tile_overlap//4)))
            
    print('Merging predictions')
    temp_full = f'{processing_dir}/full_raster.tif'
    untile_raster(f'{processing_dir}/predicted_rasters', outfile=temp_full, method='sum')
    
    print('Postprocessing predictions')
    
    with rio.open(temp_full, 'r') as src:
        raw_raster = src.read()
        prof = src.profile.copy()
    prof.update(count=1,
                compress='lzw',
                dtype='uint8')
    with rio.open(outfile, 'w', **prof) as dest:
        dest.write_band(1, raw_raster.argmax(axis=0))
    
    print('Removing intermediate files')
    rmtree(processing_dir)
    return

# %% ../../../nbs/33_engines.fastai.predict.ipynb 6
@call_parse
def predict_segmentation_fastai(path_to_model:str, #Path to pretrained model file
                                path_to_image:str, #Path to image to annotate
                                outfile:str, #Path and filename for output raster
                                processing_dir:str='temp', #Directory to save the intermediate tiles. Deleted after use
                                tile_size:int=400, #Tile size to use. Default 400x400px tiles
                                tile_overlap:int=100, #Tile overlap to use. Default 100px
                                use_tta:bool=False): #Use test-time augmentation
                               
    "CLI for semantic segmentation with fastai"
    predict_segmentation(path_to_model,
                         path_to_image,
                         outfile,
                         processing_dir,
                         tile_size,
                         tile_overlap,
                         use_tta)
