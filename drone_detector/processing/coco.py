# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/12_processing.coco.ipynb.

# %% auto 0
__all__ = ['resize_binary_mask', 'close_contour', 'binary_mask_to_polygon', 'calc_bearing', 'nor_theta', 'COCOProcessor',
           'detectron2_bbox_preds_to_coco_anns', 'detectron2_mask_preds_to_coco_anns']

# %% ../../nbs/12_processing.coco.ipynb 3
from ..imports import *
from ..utils import *
from .coordinates import *

# %% ../../nbs/12_processing.coco.ipynb 4
import datetime
from skimage import measure
from PIL import Image

# %% ../../nbs/12_processing.coco.ipynb 6
# From https://github.com/waspinator/pycococreator/blob/master/pycococreatortools/pycococreatortools.py

def resize_binary_mask(array, new_size):
    image = Image.fromarray(array.astype(np.uint8)*255)
    image = image.resize(new_size)
    return np.asarray(image).astype(np.bool_)

def close_contour(contour):
    if not np.array_equal(contour[0], contour[-1]):
        contour = np.vstack((contour, contour[0]))
    return contour

def binary_mask_to_polygon(binary_mask, tolerance=0):
    """Converts a binary mask to COCO polygon representation. Should probably be replaced with importing pycococreatortools instead.
    """
    polygons = []
    # pad mask to close contours of shapes which start and end at an edge
    padded_binary_mask = np.pad(binary_mask, pad_width=1, mode='constant', constant_values=0)
    contours = measure.find_contours(padded_binary_mask, 0.5)
    contours = np.subtract(contours, 1)
    for contour in contours:
        contour = close_contour(contour)
        contour = measure.approximate_polygon(contour, tolerance)
        if len(contour) < 3:
            continue
        contour = np.flip(contour, axis=1)
        segmentation = contour.ravel().tolist()
        # after padding and subtracting 1 we may get -0.5 points in our segmentation 
        segmentation = [0 if i < 0 else i for i in segmentation]
        polygons.append(segmentation)

    return polygons

# %% ../../nbs/12_processing.coco.ipynb 9
from pycocotools.mask import frPyObjects
from shapely.geometry import MultiPolygon

# %% ../../nbs/12_processing.coco.ipynb 10
def calc_bearing(point1, point2):
    "Get the angle of the rotated bounding box in radians"
    x1, y1 = point1
    x2, y2 = point2
    theta = math.atan2(y2 - y1, x2 - x1)
    theta = nor_theta(theta)
    return theta

def nor_theta(theta):
    "Convert angle to simpler format"
    if theta > math.radians(45):
        theta -= math.radians(90)
        theta = nor_theta(theta)
    elif theta <= math.radians(-45):
        theta += math.radians(90)
        theta = nor_theta(theta)
    return theta

# %% ../../nbs/12_processing.coco.ipynb 11
def _corners2rotatedbbox(poly):
    """Return rotated bounding box in (xc, yc, w, h, a) format used by detectron2 (xc, yc) is the center of the rotated box, a is the angle in degrees ccw"""
    centre = poly.centroid.coords.xy
    corners = np.array(poly.exterior.coords)
    theta = calc_bearing(corners[0], corners[1])
    rotation = np.array([[np.cos(theta), -np.sin(theta)],
                         [np.sin(theta), np.cos(theta)]])
    out_points = np.matmul(corners - np.array(centre).T, rotation) + np.array(centre).T
    x, y = list(out_points[0,:])
    w, h = list(out_points[2, :] - out_points[0, :])
    return [centre[0][0], centre[1][0], np.abs(w), np.abs(h), -(theta*180)/np.pi] # Convert angle from radians to ccw degrees

    
def _process_shp_to_coco(image_id, category_id, ann_id, poly:Polygon, rotated_bbox:bool=False):
    "TODO handle multipolygons"
    ann_dict = {
        'segmentation': [],
        'area': None, 
        'bbox': [],
        'category_id': category_id,
        'id' : ann_id,
        'image_id': image_id,
        'iscrowd': 0,
    }

    if poly.geom_type == 'Polygon':
        ann_dict['segmentation'] = [list(sum(poly.exterior.coords[:-1], ()))]
        if not rotated_bbox:
            ann_dict['bbox'] = [(poly.bounds[0]), 
                                (poly.bounds[1]), 
                                (poly.bounds[2]-poly.bounds[0]), 
                                (poly.bounds[3]-poly.bounds[1])]
        else: # XYWHA is the requirement for rotated bounding boxes
            ann_dict['bbox'] = _corners2rotatedbbox(poly.minimum_rotated_rectangle)
        ann_dict['area'] = poly.area
    elif poly.geom_type == 'MultiPolygon':
        temp_poly = None
        max_area = 0
        # Take only the largest polygon
        for p in poly.geoms:
            area = p.area
            if area > max_area:
                max_area = area
                temp_poly = p
        ann_dict['segmentation'] = [list(sum(temp_poly.exterior.coords[:-1], ()))]
        if not rotated_bbox:
            ann_dict['bbox'] = [(temp_poly.bounds[0]), 
                                (temp_poly.bounds[1]), 
                                (temp_poly.bounds[2]-temp_poly.bounds[0]), 
                                (temp_poly.bounds[3]-temp_poly.bounds[1])]
        else:
            ann_dict['bbox'] = _corners2rotatedbbox(temp_poly.minimum_rotated_rectangle.exterior.coords)
        ann_dict['area'] = temp_poly.area
    return ann_dict


# %% ../../nbs/12_processing.coco.ipynb 12
class COCOProcessor():
    "Handles Transformations from shapefiles to COCO-format and backwards"
    
    def __init__(self, data_path:str, outpath:str, coco_info:dict, coco_licenses:list,
                 coco_categories:list):
        store_attr()
        self.raster_path = f'{self.data_path}/images'
        self.vector_path = f'{self.data_path}/vectors'
        self.prediction_path = f'{self.data_path}/predictions'
        
        self.coco_dict = {
            'info': coco_info,
            'licenses': coco_licenses,
            'images': [],
            'annotations': [],
            'categories': coco_categories,
            'segment_info': []
        }
        self.categories = {c['name']:c['id'] for c in self.coco_dict['categories']}
        
        
    def from_shp(self, label_col:str='label', outfile:str='coco.json', min_bbox_area:int=0, 
                 rotated_bbox:bool=False):
        "Process shapefiles from self.vector_path to coco-format and save to self.outpath/outfile"
        vector_tiles = [f for f in os.listdir(self.vector_path) if f.endswith(('.shp', '.geojson'))]
        # If no annotations are in found in raster tile then there is no shapefile for that
        raster_tiles = [f'{fname.split(".")[0]}.tif' for fname in vector_tiles]
        ann_id = 1
        for i, r in tqdm(enumerate(raster_tiles)):
            tile_anns = []
            gdf = gpd.read_file(f'{self.vector_path}/{vector_tiles[i]}')
            tfmd_gdf = gdf_to_px(gdf, f'{self.raster_path}/{raster_tiles[i]}', precision=3)
            for row in tfmd_gdf.itertuples():
                category_id = self.categories[getattr(row, label_col)]
                if box(*row.geometry.bounds).area < min_bbox_area: continue # if bounding box is smaller than 4Â² pixels then exclude it
                tile_anns.append(_process_shp_to_coco(i, category_id, ann_id, row.geometry, rotated_bbox))
                ann_id += 1
            if len(tile_anns) > 0:
                with rio.open(f'{self.raster_path}/{r}') as im: 
                    h, w = im.shape
                self.coco_dict['images'].append({'file_name': raster_tiles[i],'id': i, 'height':h, 'width':w})
                self.coco_dict['annotations'].extend(tile_anns)

        with open(f'{self.outpath}/{outfile}', 'w') as f: json.dump(self.coco_dict, f)

        return
    
    def to_shp(self, coco_data:dict=None, outdir:str='predicted_vectors', downsample_factor:int=1):
        """Generates shapefiles from a dictionary with coco annotations.
        TODO handle multipolygons better"""
        
        if not os.path.exists(f'{self.outpath}/{outdir}'): os.makedirs(f'{self.outpath}/{outdir}')
        
        annotations = coco_data['annotations']
        images = coco_data['images']
        categories = coco_data['categories']
        for i in tqdm(images):
            anns_in_image = [a for a in annotations if a['image_id'] == i['id']]
            if len(anns_in_image) == 0: continue
            cats = []
            polys = []
            scores = []
            for a in anns_in_image:
                # No segmentations, only bounding boxes
                if a['segmentation'] is None:
                    cats.append(a['category_id'])
                    if len(a['bbox']) == 4:
                        # Bbox has format xmin, ymin, xdelta, ydelta
                        polys.append(box(a['bbox'][0] / downsample_factor, 
                                         a['bbox'][1] / downsample_factor, 
                                         (a['bbox'][2] + a['bbox'][0]) / downsample_factor, 
                                         (a['bbox'][3]+a['bbox'][1]) / downsample_factor))
                    elif len(a['bbox']) == 5:
                        # Rotated bbox has format x_center, y_center, w, h, angle
                        xc = a['bbox'][0]
                        yc = a['bbox'][1]
                        w = a['bbox'][2]
                        h = a['bbox'][3]
                        angle = -np.radians(a['bbox'][4])
                        ax = xc + ((w/2)*np.cos(angle)) - ((h/2)*np.sin(angle))
                        ay = yc + ((w/2)*np.sin(angle)) + ((h/2)*np.cos(angle))

                        bx = xc - ((w/2)*np.cos(angle)) - ((h/2)*np.sin(angle))
                        by = yc - ((w/2)*np.sin(angle)) + ((h/2)*np.cos(angle))

                        cx = xc - ((w/2)*np.cos(angle)) + ((h/2)*np.sin(angle))
                        cy = yc - ((w/2)*np.sin(angle)) - ((h/2)*np.cos(angle))

                        dx = xc + ((w/2)*np.cos(angle)) + ((h/2)*np.sin(angle))
                        dy = yc + ((w/2)*np.sin(angle)) - ((h/2)*np.cos(angle))
                        polys.append(Polygon([(ax,ay), (bx,by), (cx,cy), (dx,dy)]))
                    if 'score' in a.keys():
                        scores.append(a['score'])
                # Single polygon
                elif len(a['segmentation']) == 1:
                    cats.append(a['category_id'])
                    xy_coords = [(a['segmentation'][0][i]  / downsample_factor, 
                                  a['segmentation'][0][i+1] / downsample_factor) 
                                 for i in range(0,len(a['segmentation'][0]),2)]
                    xy_coords.append(xy_coords[-1])
                    polys.append(Polygon(xy_coords))
                    if 'score' in a.keys():
                        scores.append(a['score'])
                # Multipolygon 
                else: 
                    temp_poly = None
                    max_area = 0
                    cats.append(a['category_id'])
                    for p in rangeof(a['segmentation']):
                        xy_coords = [(a['segmentation'][p][i] / downsample_factor, 
                                      a['segmentation'][p][i+1] / downsample_factor) 
                                     for i in range(0,len(a['segmentation'][p]),2)]
                        xy_coords.append(xy_coords[-1])
                        if Polygon(xy_coords).area > max_area:
                            temp_poly = Polygon(xy_coords)
                            max_area = temp_poly.area
                    polys.append(temp_poly)
                    if 'score' in a.keys():
                        scores.append(a['score'])
            gdf = gpd.GeoDataFrame({'label':cats, 'geometry':polys})
            if len(scores) != 0: gdf['score'] = scores
            tfmd_gdf = georegister_px_df(gdf, f'{self.raster_path}/{i["file_name"]}')
            tfmd_gdf.to_file(f'{self.outpath}/{outdir}/{i["file_name"][:-4]}.geojson', driver='GeoJSON')
        return

    def to_coco_results(self, label_col:str='label_id', outfile:str='coco_res.json', rotated_bbox=False):
        result_tiles = [f for f in os.listdir(self.prediction_path) if f.endswith(('.shp', '.geojson'))]
        # If no annotations are in found in raster tile then there is no shapefile for that
        raster_tiles = [f'{fname.split(".")[0]}.tif' for fname in result_tiles]
        results = []
        for i in tqdm(rangeof(raster_tiles)):
            for im_id, im in enumerate(self.coco_dict['images']):
                if im['file_name'] == raster_tiles[i]:
                    break
            image_id = self.coco_dict['images'][im_id]['id']
            h = self.coco_dict['images'][im_id]['height']
            w = self.coco_dict['images'][im_id]['width']
            gdf = gpd.read_file(f'{self.prediction_path}/{result_tiles[i]}')
            tfmd_gdf = gdf_to_px(gdf, f'{self.raster_path}/{raster_tiles[i]}', precision=3)
            for row in tfmd_gdf.itertuples():
                res = {'image_id': image_id,
                       'category_id': getattr(row, label_col),
                       'segmentation': None,
                       'score': np.round(getattr(row, 'score'), 5)}
                ann = _process_shp_to_coco(image_id, getattr(row, label_col), 0, row.geometry, rotated_bbox)
                res['segmentation'] = frPyObjects(ann['segmentation'], h, w)[0]
                res['segmentation']['counts'] = res['segmentation']['counts'].decode('ascii')
                results.append(res)
        
        with open(f'{self.outpath}/{outfile}', 'w') as f: 
            json.dump(results, f)

def _corners2rotatedbbox(poly):
    """Return rotated bounding box in (xc, yc, w, h, a) format used by detectron2
    (xc, yc) is the center of the rotated box, a is the angle in degrees ccw"""
    centre = poly.centroid.coords.xy
    corners = np.array(poly.exterior.coords)
    theta = calc_bearing(corners[0], corners[1])
    rotation = np.array([[np.cos(theta), -np.sin(theta)],
                         [np.sin(theta), np.cos(theta)]])
    out_points = np.matmul(corners - np.array(centre).T, rotation) + np.array(centre).T
    x, y = list(out_points[0,:])
    w, h = list(out_points[2, :] - out_points[0, :])
    return [centre[0][0], centre[1][0], np.abs(w), np.abs(h), -(theta*180)/np.pi] # Convert angle from radians to ccw degrees

# %% ../../nbs/12_processing.coco.ipynb 14
from detectron2.structures.rotated_boxes import RotatedBoxes

# %% ../../nbs/12_processing.coco.ipynb 15
def detectron2_bbox_preds_to_coco_anns(images:list, preds:list) -> dict:
    """Process detectron2 prediction to COCO-annotation polygon format. Returns a dict with COCO-style `images` and `annotations`
    """
    outdict = {}
    outdict['annotations'] = []
    outdict['images'] = images

    for i in tqdm(rangeof(preds)):
        p = preds[i]['instances']
        for j in rangeof(p.pred_classes):
            anns = []
            ann_dict = {
                'segmentation': None,
                'area': None,  
                'iscrowd': 0,
                'category_id': p.pred_classes[j].item(),
                'id': i+1,
                'image_id': images[i]['id'],
                'score': p.scores[j].item()
            }
            if isinstance(p.pred_boxes[j], RotatedBoxes): #xywha_abs
                ann_dict['bbox'] = [p.pred_boxes[j].tensor[0,0].item(),
                                    p.pred_boxes[j].tensor[0,1].item(),
                                    p.pred_boxes[j].tensor[0,2].item(),
                                    p.pred_boxes[j].tensor[0,3].item(),
                                    p.pred_boxes[j].tensor[0,4].item()]
            else: # xyxy_abs -> xywh_abs
                ann_dict['bbox'] = [p.pred_boxes[j].tensor[0,0].item(), 
                                    p.pred_boxes[j].tensor[0,1].item(),
                                    p.pred_boxes[j].tensor[0,2].item() - p.pred_boxes[j].tensor[0,0].item(),
                                    p.pred_boxes[j].tensor[0,3].item() - p.pred_boxes[j].tensor[0,1].item()]
            anns.append(ann_dict)
            outdict['annotations'].extend(anns)

    return outdict


def detectron2_mask_preds_to_coco_anns(images:list, preds:list) -> dict:
    """Process detectron2 prediction to COCO-annotation polygon format. Returns a dict with COCO-style `images` and `annotations`
    """
    outdict = {}
    outdict['annotations'] = []
    outdict['images'] = images

    for i in tqdm(rangeof(preds)):
        p = preds[i]['instances']
        for j in rangeof(p.pred_classes):
            anns = []
            ann_dict = {
                'segmentation': binary_mask_to_polygon(p.pred_masks[j].cpu().numpy()),
                'area': None,  
                'iscrowd': 0,
                'category_id': p.pred_classes[j].item(),
                'id': i+1,
                'image_id': images[i]['id'],
                'bbox': [p.pred_boxes[j].tensor[0,0].item(), 
                         p.pred_boxes[j].tensor[0,1].item(),
                         p.pred_boxes[j].tensor[0,2].item() - p.pred_boxes[j].tensor[0,0].item(),
                         p.pred_boxes[j].tensor[0,3].item() - p.pred_boxes[j].tensor[0,1].item()],
                'score': p.scores[j].item()
            }
            if len(ann_dict['segmentation']) == 0:
                # Quickhack, find reason for empty annotation masks later
                continue
            anns.append(ann_dict)
            outdict['annotations'].extend(anns)

    return outdict
