# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/14_processing.yolo.ipynb.

# %% auto 0
__all__ = ['YOLOProcessor']

# %% ../../nbs/14_processing.yolo.ipynb 3
from ..imports import *
from ..utils import *
from .coordinates import *
import yaml

# %% ../../nbs/14_processing.yolo.ipynb 5
class YOLOProcessor():
    "Handles transformations from GIS-polygons to YOLOv8-format and backwards"
    
    def __init__(self, data_path:str, outpath:str, names:list):
        store_attr()
        self.raster_path = f'{self.data_path}/images'
        self.vector_path = f'{self.data_path}/vectors'
        self.prediction_path = f'{self.data_path}/predictions'
        self.annotation_path = f'{self.data_path}/labels'
        os.makedirs(self.annotation_path, exist_ok=True)
        self.names = {n: i for i, n in enumerate(names)}
        
    def from_shp(self, label_col:str='label', outfile:str='yolo.yaml', min_bbox_area:int=0,
                 ann_format:str='polygon'):
        "Processes GIS-polygon data to YOLOv8-format"
        if ann_format not in ['polygon', 'box']:
            print('Annotation format must be either "polygon", "box" or "rotated box", defaulting to "polygon"')
        vectors = [f for f in os.listdir(self.vector_path) if f.endswith(('.shp', 'geojson'))]
        rasters = [f'{fname.split(".")[0]}.tif' for fname in vectors]
               
        for i, r in tqdm(enumerate(rasters)):
            gdf = gpd.read_file(f'{self.vector_path}/{vectors[i]}')
            if ann_format == 'rotated_bbox':
                gdf['geometry'] = gdf.geometry.apply(lambda row: row.minimum_rotated_rectangle)
            tfmd_gdf = gdf_to_px(gdf, f'{self.raster_path}/{r}', precision=3) # to pixel coordinates
            with rio.open(f'{self.raster_path}/{r}') as im:
                h, w = im.shape
            anns = []
            for row in tfmd_gdf.itertuples():
                cat_id = self.names[getattr(row, label_col)]
                if box(*row.geometry.bounds).area < min_bbox_area: continue
                if ann_format == 'box': #classid x_c y_c w h
                    x_c = row.geometry.centroid.x / w
                    y_c = row.geometry.centroid.y / h
                    b_w = (row.geometry.bounds[2]-row.geometry.bounds[0])/w
                    b_h = (row.geometry.bounds[3]-row.geometry.bounds[1])/h
                    anns.append(f'{cat_id} {x_c} {y_c} {b_w} {b_h}')
                    
                else: #classid x y x y ...
                    coords = ' '.join(list(sum([(str(x/w), str(y/h))for x, y in row.geometry.exterior.coords[:-1]], ())))
                    anns.append(str(cat_id) + ' ' + coords)
                    
                with open(f'{self.annotation_path}/{r.replace("tif", "txt")}', 'w') as dest:
                    for ann in anns: dest.write(f'{ann}\n')             

        with open(self.data_path/outfile, 'w') as dest:
            # Todo handle specifying train/val/test .-sets
            dest.write('# Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3: list: [path/to_imgs1, path_to_imgs2, ..]\n')
            dest.write(f'path: {self.data_path} # dataset root dir \n')
            dest.write(f"train: # train images (relative to 'path')\n")
            dest.write(f"val: # val images (relative to 'path')\n")
            dest.write(f"test: # test images (relative to 'path')\n")
            dest.write('\n# Classes\n')
            dest.write('names:\n')
            for n in self.names.keys():
                dest.write(f'  {self.names[n]}: {n}\n')
                        
                        
    def to_shp(self, yolo_data:dict=None, outdir:str='predicted_vectors', downsample_factor:int=1,
               ann_format:str='polygon'):
        """Assume that results have similar format than images, but they are in a folder `predictions`.
        ann_format is one of `polygon`, `xyxy`, `xywh`, `xyxyn`, `xywhn`.
        """
        
        if ann_format not in ['polygon', 'xyxy', 'xywh', 'xyxyn', 'xywhn']:
            print(f'ann_format must be one of polygon, xyxy, xywh, xyxyn, xywhn, was {ann_format}')
            return
        
        pred_files = os.listdir(self.data_path/'predictions')
        names = yolo_data['names']
        
        for p in tqdm(pred_files):
            with open(self.data_path/'predictions'/p, 'r') as f:
                preds = [line.rstrip() for line in f]
            with rio.open(self.data_path/'images'/p.replace('txt', 'tif')) as im:
                h, w = im.shape
            labels = []
            polys = []
            scores = []
            if ann_format == 'polygon':
                for pred in preds: # label x y x y x y ... x y conf
                    if len(pred) == 0: continue
                pred = pred.split(' ')
                label = labels.append(int(pred[0]))
                score = scores.append(float(pred[-1]))
                xs = [float(pred[i])*w for i in range(1, len(pred), 2)]
                ys = [float(pred[i])*h for i in range(2, len(pred), 2)]
                xy_coords = list(zip(xs, ys))
                xy_coords.append(xy_coords[-1])
                polys.append(Polygon(xy_coords))    
            if ann_format in ['xyxy', 'xyxyn']: # label x1 y1 x2 y2 conf
                for pred in preds:
                    if len(pred) == 0: continue
                label, x1, y1, x2, y2, score = pred.split(' ')
                labels.append(int(label))
                scores.append(float(score))
                x1 = float(x1) * w if ann_format == 'xyxyn' else float(x1)
                y1 = float(y1) * h if ann_format == 'xyxyn' else float(y1)
                x2 = float(x2) * w if ann_format == 'xyxyn' else float(x2)
                y2 = float(y2) * h if ann_format == 'xyxyn' else float(y2)
                polys.append(box(x1, y1, x2, y2))
            elif ann_format in ['xywh', 'xywhn']: # label xc yc bw bh conf:
                for pred in preds:
                    if len(pred) == 0: continue
                label, xc, yc, bw, bh, score = pred.split(' ')
                labels.append(int(label))
                scores.append(float(score))
                xc = float(xc) * w if ann_format == 'xywhn' else float(xc)
                yc = float(yc) * h if ann_format == 'xywhn' else float(yc)
                bw = float(bw) * w if ann_format == 'xywhn' else float(bw)
                bh = float(bh) * h if ann_format == 'xywhn' else float(bh)
                polys.append(box(xc - (bw/2), yc - (bh/2), xc+(bw/2), y2+(bh/2))) 
            gdf = gpd.GeoDataFrame({'label': labels, 'geometry': polys, 'score': scores})
            tfmd_gdf = georegister_px_df(gdf, f'{self.raster_path}/{p.replace("txt", "tif")}')
            tfmd_gdf.to_file(f'{self.outpath}/{outdir}/{p.replace("txt", "geojson")}', driver='GeoJSON')
        return
